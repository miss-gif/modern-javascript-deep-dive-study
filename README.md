# 모던 자바스크립트 Deep Dive

## 1장 프로그래밍

### 1.1 프로그래밍이란?

1. 컴퓨터에게 명령을 내리는 과정입니다.
2. 컴퓨터는 기계어를 사용하여 명령을 이해하고 실행합니다.
   하지만, 사람은 기계어 대신 자연어를 사용합니다.
3. 프로그래밍 언어로 사람이 이해할 수 있는 형태로 명령을 작성하고, 컴퓨터가 이를 이해하여 실행합니다.

프로그래밍은 컴퓨터에게 작업을 지시하는 과정으로, 요구사항을 정확하고 상세하게 표현하는 작업입니다.

### 1.2 프로그래밍 언어

프로그래밍 언어는 사람과 컴퓨터 간의 커뮤니케이션을 위한 도구입니다.

프로그래밍 언어는 구문(syntax)과 의미론(semantics)의 조합으로 이루어져 있습니다.

- 구문(syntax)은 프로그래밍 언어에서 문장을 구성하는 규칙의 모음입니다.
- 의미론(semantics)은 프로그래밍 언어에서 문장의 의미나 실행 결과를 정의하는 것입니다.

구문 = 문법

### 1.3 구문(syntax)과 의미(semantics)

```js
let x = 5;
let y = 3;
let sum = x + y;
console.log(sum); // 출력 결과: 8
```

**구문은 코드를 작성하는데 사용되는 문법적인 요소들을 의미합니다.**

```js
let x = 5;
let y = 3;
```

변수를 선언하는 방법이나 조건문을 작성하는 방법 등이 자바스크립트의 구문에 해당합니다.

**의미(Semantics)는 코드의 실질적인 기능이나 작업을 나타냅니다.**

```js
let sum = x + y;
console.log(sum); // 출력 결과: 8
```

변수 조작과 결과 출력은 의미에 해당합니다.

프로그래밍은 요구사항을 분석하여 적절한 자료구조와 함수의 집합으로 변환하고, 프로그램의 흐름을 제어하여 원하는 동작을 구현하는 과정입니다.

## 2장 자바스크립트란?

### 2.1 자바스크립트의 탄생

탄생:

- 1995년 넷스케이프 커뮤니케이션즈의 브렌단 아이크(Brendan Eich) 개발
- 초기 이름: 라이브스크립트 (LiveScript)
- 최종 이름: 자바스크립트 (JavaScript) - 자바 인기 영향, 하지만 자바와는 별개의 언어

목적:

- 웹 페이지에 인터랙티브한 요소 추가
- 초기: 간단한 웹 페이지 상호 작용
- 현재: 웹 개발 필수 요소

변화:

- 간단한 스크립트 언어에서 웹 개발 필수 요소로 진화

### 2.2 자바스크립트의 표준화

초기에는 각 웹 브라우저마다 독자적인 자바스크립트 엔진이 존재했고, 이는 호환성 문제를 야기했습니다.

문제점:

- 호환성 문제: 동일한 코드라도 브라우저마다 다르게 동작하여 예상치 못한 결과를 초래했습니다.
- 개발 비용 증가: 개발자들은 각 브라우저를 대상으로 코드를 테스트하고 수정해야 했기 때문에 개발 비용이 증가했습니다.
- 코드 유지 관리 어려움: 브라우저마다 버전이 업데이트될 때마다 코드를 수정해야 했기 때문에 코드 유지 관리가 어려웠습니다.

표준화의 등장:

- 1997년, 자바스크립트의 초안이 ECMA International(전기전자기술협회)에서 ECMAScript 표준으로 채택되었습니다. 이를 통해 자바스크립트의 표준화가 이루어지고, 다양한 브라우저에서 동일한 코드가 동일한 방식으로 작동할 수 있게 되었습니다.

- 이후 ECMAScript 표준은 지속적으로 발전해왔고, 새로운 기능이 추가되고 기존 기능이 개선되었습니다. 이를 통해 개발자들은 더욱 효율적으로 코드를 작성하고, 다양한 환경에서 일관된 동작을 보장할 수 있게 되었습니다.

- 요약하면, 자바스크립트 표준화는 웹의 발전과 호환성 문제를 해결하기 위해 이루어졌으며, ECMAScript 표준을 통해 다양한 환경에서 일관된 개발이 가능해졌습니다.

### 2.3 자바스크립트 성장의 역사

초기의 자바스크립트는 주로 웹페이지의 보조 기능을 담당했고, 브라우저는 HTML과 CSS를 단순히 렌더링하는데 그쳤습니다.

- 렌더링은 웹 브라우저에서 HTML, CSS, JavaScript 코드를 해석하고 시각적으로 표현하여 사용자가 웹 페이지를 볼 수 있도록 하는 과정입니다.

**렌더링 과정**

1. HTML 파싱 및 DOM 생성:

   - 브라우저는 HTML 코드를 해석하여 웹 페이지의 구조를 나타내는 DOM 트리를 만듭니다.
   - DOM 트리는 각 HTML 요소, 속성, 계층 관계를 나타냅니다.

> DOM(문서 객체 모델) 트리는 웹 페이지의 구조를 표현하는 계층적인 트리 구조입니다.
> 노드(Node): DOM 트리의 기본 단위이며, 요소, 문서, 텍스트 등을 나타낼 수 있습니다.
> 요소(Element): HTML 태그를 나타내는 노드입니다. 각 요소는 속성(attribute)과 자식 요소(child element)를 가질 수 있습니다.
> 문서(Document): DOM 트리의 최상위 노드이며, 전체 HTML 문서를 나타냅니다.
> 텍스트(Text): 요소 내의 텍스트 콘텐츠를 나타내는 노드입니다.

2. CSS 파싱 및 CSSOM 생성:

   - 브라우저는 CSS 코드를 해석하여 웹 페이지의 디자인을 나타내는 CSSOM 트리를 만듭니다.
   - CSSOM 트리는 각 HTML 요소에 적용되는 스타일 정보를 나타냅니다.

3. 렌더 트리 생성:

   - DOM 트리와 CSSOM 트리를 기반으로 실제로 화면에 표현되는 렌더 트리가 생성됩니다.

4. 자바스크립트 실행:

   - 자바스크립트 코드는 웹 페이지의 동적인 변화를 가능하게 합니다.
   - DOM 조작, CSS 스타일 변경, 레이아웃 계산, 애니메이션 등이 가능합니다.

5. 레이아웃 및 페인팅:

   - 렌더 트리를 기반으로 웹 페이지의 레이아웃을 계산하고 각 요소를 화면에 그립니다.

#### 2.3.1 Ajax

Ajax(Asynchronous JavaScript and XML)는 웹 애플리케이션에서 비동기적으로 서버와 통신하여 페이지 새로 고침 없이 데이터를 업데이트하는 기술입니다.

> 비동기 서버 통신은 클라이언트가 서버에 요청을 보낸 후 즉시 응답을 기다리지 않고 다른 작업을 수행할 수 있는 방식입니다. 이는 클라이언트의 응답성을 향상시키고 서버의 성능을 개선하는 데 도움이 될 수 있습니다.

XMLHttpRequest(XHR) 객체를 사용하여 요청과 응답을 처리하며, 이를 통해 웹 페이지의 사용자 경험을 향상시킬 수 있습니다.

```js
// XMLHttpRequest 객체 생성
var xhr = new XMLHttpRequest();

// 서버로부터 데이터를 받아오는 이벤트 핸들러 설정
xhr.onreadystatechange = function () {
  if (xhr.readyState === XMLHttpRequest.DONE) {
    // 요청이 완료되었을 때
    if (xhr.status === 200) {
      // 요청이 성공했을 때
      console.log(xhr.responseText); // 서버로부터 받은 데이터 출력
    } else {
      console.error("요청 실패: " + xhr.status); // 요청이 실패했을 때 에러 메시지 출력
    }
  }
};

// HTTP GET 요청 설정
xhr.open("GET", "https://api.example.com/data", true);

// 요청 전송
xhr.send();
```

#### 2.3.2 jQuery

제이쿼리(jQuery)는 2006년에 개발된 자바스크립트 라이브러리로, 웹 개발을 간편하고 효율적으로 만들어 주는 도구입니다. 브라우저 호환성 문제를 해결하고, 간결한 문법으로 HTML 요소를 선택하고 조작할 수 있으며, 동적인 콘텐츠 조작과 이벤트 처리를 용이하게 합니다.

최근에는 웹 표준과 브라우저의 발전으로 인해 제이쿼리에 대한 의존도가 줄어들고 있지만, 여전히 많은 개발자들이 사용하고 있습니다.

#### 2.3.3 V8 자바스크립트 엔진

구글에서 개발한 V8 자바스크립트 엔진은 웹 개발의 성능과 속도를 향상시키는 핵심 기술로,
V8 엔진의 등장은 웹 애플리케이션의 발전과 프론트엔드 개발의 중요성을 더욱 부각시켰습니다.

V8 엔진의 영향:

- 클라이언트 측 로직 증가: 과거에는 웹 서버에서 처리하던 많은 로직들이 V8 엔진의 성능 향상으로 인해 클라이언트 측으로 이동했습니다. 이는 프론트엔드 개발자들에게 더 많은 책임과 가능성을 부여했습니다.
- 풍부한 프론트엔드 프레임워크 등장: React, Angular, Vue.js와 같은 다양한 프론트엔드 프레임워크들이 등장하여 복잡한 프론트엔드 애플리케이션 개발을 용이하게 했습니다.
- SPA(Single Page Application)의 발달: V8 엔진은 SPA 개발에 필수적인 역할을 했습니다. SPA는 웹 페이지 전체를 한 번에 로드하는 대신, 필요한 부분만 동적으로 로드하여 사용자 경험을 향상시킵니다.
- 실시간 웹 애플리케이션의 등장: WebSockets와 같은 기술과 결합하여 실시간 채팅, 게임, 데이터 시각화 등 다양한 실시간 웹 애플리케이션 개발이 가능해졌습니다.

프론트엔드 영역의 주목:

V8 엔진의 영향으로 프론트엔드 개발은 단순히 웹 페이지의 디자인과 레이아웃을 만드는 역할을 넘어서, 복잡한 기능을 구현하고 사용자 경험을 책임지는 중요한 분야로 성장했습니다.

#### 2.3.4 Node.js

Node.js는 Google에서 개발한 오픈 소스 자바스크립트 런타임 환경입니다.
웹 브라우저 외부에서, 즉 서버 측에서 자바스크립트 코드를 실행할 수 있도록 해줍니다.

Node.js의 특징:

- 이벤트 기반 비동기 프로그래밍: 여러 클라이언트 요청을 동시에 처리하여 성능 향상
- 자바스크립트 통합: 프론트엔드 개발자들이 쉽게 백엔드 개발 가능
- 풍부한 패키지 관리 시스템: npm을 통한 라이브러리 설치 및 관리 용이
- 실시간 애플리케이션 개발: 웹 소켓 등을 활용한 실시간 애플리케이션 개발에 적합

Node.js가 사용되는 분야:

- 실시간 웹 애플리케이션: 채팅, 멀티 플레이어 게임, 데이터 스트리밍 등
- 마이크로서비스 아키텍처 (Microservices Architecture): 복잡한 애플리케이션을 작은 독립적인 서비스의 집합으로 개발하는 방식에서 자주 활용
- API 개발: 웹 애플리케이션과 모바일 앱 간의 데이터 교환을 위한 API 개발에 활용

Node.js의 장점:

- 빠른 개발: JavaScript를 사용하여 서버 측 개발을 할 수 있으므로 개발 속도가 빠릅니다.
- 높은 성능: 이벤트 기반 비동기 프로그래밍 모델 덕분에 높은 성능을 자랑합니다.
- 단일 언어: 프론트엔드와 백엔드 모두 자바스크립트를 사용할 수 있어 개발 및 유지보수가 용이합니다.

Node.js의 단점:

- CPU 집약적인 작업에는 적합하지 않음: Node.js는 단일 스레드 모델을 사용하기 때문에 CPU 집약적인 작업에는 적합하지 않습니다.
- 성숙한 라이브러리 부족: 상대적으로 다른 서버 측 언어에 비해 성숙한 라이브러리 수가 적다.

#### 2.3.5 SPA 프레임워크

> CBD(Component-Based Development) 방법론은 재사용 가능한 컴포넌트를 기반으로 소프트웨어 개발을 하는 방식입니다. 컴포넌트는 독립적이고 재사용 가능하며, 명확한 인터페이스를 통해 상호 작용합니다. CBD 방법론을 사용하면 개발 생산성과 품질을 향상시키고 유지보수 비용을 줄일 수 있습니다.

SPA(Single Page Application) 프레임워크는 웹 애플리케이션을 단일 페이지로 개발하고 동적으로 콘텐츠를 업데이트하는 데 사용되는 프레임워크입니다. 기존 웹 페이지와 달리 페이지를 새로고침하지 않고도 사용자 상호 작용에 따라 데이터를 가져와 DOM을 업데이트하여 사용자 경험을 향상시킵니다.

SPA 프레임워크의 주요 특징:

- 단일 페이지: 웹 애플리케이션이 단일 페이지로 구성되어 페이지 로딩 시간을 줄이고 사용자 경험을 향상시킵니다.
- 동적 콘텐츠 업데이트: AJAX 및 기타 비동기 기술을 사용하여 페이지를 새로고침하지 않고도 데이터를 가져와 DOM을 업데이트합니다.
- 클라이언트 측 라우팅: URL 변경에 따라 애플리케이션 내 다른 뷰로 이동하도록 클라이언트 측 라우팅을 처리합니다.

SPA 프레임워크의 장점:

- 향상된 사용자 경험: 페이지 로딩 시간 감소, 매끄러운 애니메이션, 반응형 디자인 제공
- 단일 코드베이스: 프론트엔드와 백엔드를 하나의 코드베이스로 개발 가능
- 모바일 최적화: 모바일 기기에서 사용하기에 적합
- 오프라인 기능 구현 가능: 일부 SPA 프레임워크는 오프라인에서도 작동하도록 지원

SPA 프레임워크의 단점:

- SEO 어려움: 초기 페이지 로드만 검색 엔진에 인덱싱될 수 있어 SEO에 어려움을 겪을 수 있음
- 복잡도 증가: SPA는 기존 웹 페이지보다 개발 및 유지 관리가 더 복잡할 수 있음
- 딥 링킹 제한: 특정 뷰에 직접 링크하기 어려울 수 있음

대표적인 SPA 프레임워크:

- React: Facebook에서 개발한 JavaScript 라이브러리로, 가상 DOM을 사용하여 효율적인 렌더링과 데이터 흐름 관리를 제공합니다.
- Angular: Google에서 개발한 TypeScript 기반 오픈 소스 프레임워크로, 구성 요소 기반 아키텍처와 MVC 패턴을 사용하여 구조적이고 확장 가능한 애플리케이션 개발을 지원합니다.
- Vue.js: Yuxiang “Evan You” Qiu가 개발한 JavaScript 프레임워크로, 가볍고 사용하기 쉬우면서도 다양한 기능을 제공합니다.

SPA 프레임워크 선택:

프로젝트의 요구 사항과 개발자의 선호도에 따라 적합한 SPA 프레임워크를 선택하는 것이 중요합니다.

- 프로젝트 규모 및 복잡성
- 개발자 팀의 기술 스택
- 필요한 기능
- 성능 및 확장성
- 커뮤니티 지원

### 2.4 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준화된 버전을 정의하는 스크립트 언어 사양으로, 웹 브라우저 및 다른 환경에서 일관된 자바스크립트 동작을 보장합니다. 이 표준은 Ecma International이 관리하며, 새로운 기능과 업데이트된 문법을 포함하여 언어의 발전을 이끌어냅니다. 현재 가장 널리 사용되는 버전은 ECMAScript 6(또는 ES6)이며, ES6 이후의 버전도 지속적인 발전이 이루어지고 있습니다.

### 2.5 자바스크립트의 특징

- 인터프리터 언어

> 컴파일러 언어는 소스 코드를 한 번에 전체적으로 기계어로 변환하는 프로그램입니다. 컴파일된 프로그램은 실행 속도가 빠르고 독립 실행이 가능하며 메모리 효율적이지만, 컴파일 시간이 길고 플랫폼 의존적이며 디버깅이 어려울 수 있습니다.

> 인터프리터 언어는 소스 코드를 한 줄씩 해석하고 실행하는 프로그램입니다. 인터프리터 언어는 개발 속도가 빠르고 플랫폼 독립적이며 디버깅이 쉽지만, 실행 속도가 느리고 메모리 사용량이 많으며 실행 파일을 생성하지 못합니다.

> 적절한 언어 선택:
> 빠른 실행 속도와 독립 실행성이 중요한 경우: 컴파일러 언어 (C, C++, Java, Go, Rust)
> 빠른 개발 속도와 플랫폼 독립성이 중요한 경우: 인터프리터 언어 (Python, JavaScript, Ruby)

- 멀티 패러다임 프로그래밍 언어: 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원합니다. 이는 다양한 문제에 대해 가장 적합한 프로그래밍 패러다임을 선택할 수 있게 합니다.

> 명령형 프로그래밍: 명령형 프로그래밍은 코드가 어떻게 실행되어야 하는지를 명시적으로 정의하는 방식입니다. 이는 프로그램이 연속적인 상태 변화를 통해 실행되는 방식을 나타냅니다. 자바스크립트에서는 변수, 조건문, 반복문 등을 사용하여 명령형 프로그래밍을 구현할 수 있습니다.

```js
// 명령형 방식으로 배열의 모든 요소를 합하는 예시 코드
function sum(arr) {
  let result = 0;
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}

const numbers = [1, 2, 3, 4, 5];
console.log(sum(numbers)); // 출력: 15
```

> 함수형 프로그래밍: 함수형 프로그래밍은 함수를 일급 객체로 취급하고, 함수 조합과 고차 함수를 사용하여 프로그램을 작성하는 방식입니다. 이는 부작용을 피하고, 상태 변화를 줄이는 데 중점을 둡니다. 자바스크립트는 클로저, 고차 함수, 익명 함수 등을 통해 함수형 프로그래밍을 지원합니다.

```js
// 함수형 방식으로 배열의 모든 요소를 합하는 예시 코드
const sum = (arr) => arr.reduce((acc, curr) => acc + curr, 0);

const numbers = [1, 2, 3, 4, 5];
console.log(sum(numbers)); // 출력: 15
```

> 프로토타입 기반 객체지향 프로그래밍: 자바스크립트는 프로토타입 기반 객체지향 프로그래밍을 사용합니다. 이는 클래스가 아닌 프로토타입을 사용하여 객체를 생성하고 상속하는 방식을 말합니다. 자바스크립트에서는 객체와 프로토타입을 사용하여 객체 지향적인 코드를 작성할 수 있습니다.

```js
// 프로토타입 기반 객체 생성 예시 코드
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.sayHello = function () {
  console.log(`안녕하세요, 저는 ${this.name}이고, ${this.age}살입니다.`);
};

const person1 = new Person("Alice", 30);
person1.sayHello(); // 출력: 안녕하세요, 저는 Alice이고, 30살입니다.
```

- 프로토타입 기반의 객체지향 언어: 자바스크립트는 클래스 기반의 객체지향 언어가 아닌 프로토타입 기반의 객체지향 언어입니다. 객체를 생성할 때 다른 객체의 프로토타입을 사용하여 유연성과 재사용성을 높입니다.

> 1. 클래스 기반 객체지향 언어:
>    클래스를 기본 단위로 객체를 설계하고 구현합니다.
>    상속과 다형성을 강력하게 지원합니다.
>    대표적인 언어로는 Java, C++, C#, Python 등이 있습니다.

> 2. 프로토타입 기반 객체지향 언어:
>    클래스 대신 프로토타입을 사용하여 객체를 설계하고 구현합니다.
>    프로토타입은 객체의 속성과 메서드를 포함하는 객체입니다.
>    상속은 프로토타입 체인을 통해 이루어집니다.
>    대표적인 언어로는 JavaScript, Self, Lua 등이 있습니다.

- 동적 언어: 자바스크립트는 동적 언어로 변수의 자료형을 명시적으로 선언할 필요가 없습니다.

```js
// 변수 선언 및 값 할당
var dynamicVar = 10;

// 동적으로 타입이 결정됨
console.log(typeof dynamicVar); // 출력: number

// 문자열을 할당하여 타입이 자동으로 변함
dynamicVar = "Hello, world!";

// 다시 동적으로 타입이 결정됨
console.log(typeof dynamicVar); // 출력: string
```

- 단일 스레드 언어: 자바스크립트는 단일 스레드 언어로 여러 작업을 동시에 처리할 수 없지만, 비동기 프로그래밍을 통해 비동기적으로 작업을 처리할 수 있습니다.

> 단일 스레드 언어인데도 자바스크립트에서 비동기 작업을 수행할 수 있는 이유는 비동기 프로그래밍 모델과 이벤트 루프(event loop)라는 메커니즘 때문입니다.

> 비동기 프로그래밍 모델: 콜백(callback), 프로미스(promise), 비동기 함수(async function) 등을 통해 구현됩니다. 이 모델은 작업을 순차적으로 실행하는 대신에 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있게 해줍니다. 예를 들어, 파일을 읽거나 네트워크 요청을 보내는 등의 작업은 비동기적으로 수행됩니다.

> 이벤트 루프(event loop): 자바스크립트 엔진은 단일 스레드로 동작하면서도 이벤트 루프를 통해 비동기 작업을 처리할 수 있습니다. 이벤트 루프는 메인 스레드에서 실행되는 무한 루프로, 이벤트 큐(event queue)에서 이벤트를 받아 실행 스택(call stack)에 추가하는 역할을 합니다. 비동기 작업이 완료되면 해당 작업의 콜백 함수가 이벤트 큐에 추가되고, 이벤트 루프는 이벤트 큐에 있는 작업을 실행 스택으로 옮겨 실행합니다. 이를 통해 비동기 작업의 결과를 처리하고 다음 작업을 진행할 수 있습니다.

- 웹 프로그래밍 표준 언어: 자바스크립트는 웹 브라우저에서 동적으로 웹 페이지를 변경하는 데 사용되는 표준 언어입니다.

- 서버 프로그래밍 가능: Node.js와 같은 환경에서도 자바스크립트를 사용하여 서버 측 프로그래밍이 가능합니다.

### 2.6 ES6 브라우저 지원 현황

## 3장 자바스크립트 개발 환경과 실행 방법

### 3.1 자바스크립트 실행 환경

실행 환경

- 브라우저: 웹 표시 및 사용자 상호작용 제어 (HTML, CSS와 함께 작동)
- Node.js: 서버 측 자바스크립트 실행 (웹 서버, 네트워크 애플리케이션, 백엔드 서비스 등)

API 및 모듈

- 브라우저: DOM, BOM, XMLHttpRequest, Fetch API 등 웹 페이지 조작 및 네트워크 관련 API, Canvas, Web Audio, WebGL 등 웹 기능 관련 API
- Node.js: CommonJS 기반 모듈 시스템, fs (파일 시스템), net (네트워킹), stream (데이터 처리) 등 기본 모듈, npm으로 다양한 타사 모듈 설치 및 활용 가능

> API는 "Application Programming Interface"의 약자로, 프로그램 간 상호 작용을 위한 인터페이스를 의미합니다. 간단히 말해, 소프트웨어 구성 요소들이 서로 통신할 수 있는 방법을 정의하는 것입니다.

주요 활용 분야

- 브라우저: 웹 페이지 동적 기능 (사용자 상호작용, 애니메이션, 데이터 시각화), SPA, 웹 게임, 브라우저 확장 개발
- Node.js: 웹 서버 개발 (Express, Koa), 소켓 프로그래밍, API 개발, 백엔드 서비스 (데이터베이스 연동, 인증 시스템), CLI 도구 개발

핵심 차이점

- 목적: 브라우저는 웹 페이지 표시, Node.js는 서버 측 로직 처리
- API: 브라우저는 웹 페이지 관련, Node.js는 서버 측 관련
- 활용: 브라우저는 프론트엔드, Node.js는 백엔드

> 웹 크롤링은 웹 상의 정보를 자동으로 수집하는 과정입니다. 이를 위해 크롤러(crawler)라는 프로그램을 사용하며, 크롤러는 웹 페이지를 방문하고, 해당 페이지의 링크를 추적하며, 다시 그 링크를 통해 새로운 페이지를 방문하면서 정보를 수집합니다. 수집된 정보는 데이터베이스에 저장하거나, 분석하거나, 다른 용도로 활용될 수 있습니다.

### 3.2 웹 브라우저

#### 3.2.1 개발자 도구

#### 3.2.2 콘솔

#### 3.2.3 브라우저에서 자바스크립트 실행

#### 3.2.4 디버깅

### 3.3 Node.js

#### 3.3.1 Node.js와 npm 소개

- NPM은 Node.js 패키지 관리자를 의미하며, 자바스크립트 개발에 필요한 패키지들을 설치하고 관리하는 데 사용되는 도구입니다.
- CLI는 Command Line Interface의 약자로, 명령어를 사용하여 컴퓨터를 조작하는 인터페이스를 의미합니다.

#### 3.3.2 Node.js 설치

Node.js LTS는 장기 지원 버전을 의미하며, 안정성과 보안 유지 보수가 장기적으로 제공되는 Node.js 버전입니다. 몇 가지 중요한 특징이 있습니다.

- 안정성: LTS 버전은 철저한 테스트를 거쳐 가장 안정적인 Node.js 버전으로 간주됩니다. 따라서 프로덕션 환경에 배포되는 서버 애플리케이션에 적합합니다.
- 장기 지원: LTS 버전은 최소 18개월 이상의 활발한 지원 기간과 12개월 이상의 유지 보수 기간을 제공합니다. 이 기간 동안에는 버그 수정, 보안 패치가 정기적으로 제공됩니다.
- 예측 가능성: 장기 지원 기간 덕분에 개발자는 애플리케이션을 최신 LTS 버전으로 업데이트할 시점을 예측할 수 있습니다.

`$ node -v` Node.js 설치 버전 확인
`$ npm -v` NPM 설치 버전 확인

#### 3.3.3 Node.js REPL

### 3.4 비주얼 스튜디오 코드

#### 3.4.1 비주얼 스튜디오 코드 설치

#### 3.4.2 내장 터미널

#### 3.4.3 Code Runner 확장 플러그인

#### 3.4.4 Live Server 확장 플러그인

## 04장: 변수(variable)

### 4.1 변수란 무엇인가? 왜 필요한가?

- 메모리는 데이터를 저장하는 공간으로, 여러 개의 메모리 셀로 구성됩니다.
  각 셀은 1바이트(8비트)의 크기를 가지며, 컴퓨터는 이러한 메모리 셀을 단위로 데이터를 읽거나 저장합니다.
  각 셀은 고유한 메모리 주소를 가지며, 이 주소는 메모리 공간의 위치를 나타냅니다.
- 주소는 0부터 시작하여 메모리의 크기만큼 정수로 표현됩니다.
  컴퓨터는 모든 데이터를 2진수로 처리하며, 이는 숫자, 텍스트, 이미지, 동영상 등의 데이터 종류에 상관없이 적용됩니다. 메모리에 저장되는 모든 데이터는 2진수로 변환되어 저장됩니다.
- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있습니다.
  잘못된 주소로 접근하면 시스템이 충돌하거나 데이터가 손상될 수 있으므로, 이를 피하기 위해서는 신중한 접근이 필요합니다.

변수(variable)는 값을 저장하는 메모리 공간 또는 그 공간을 가리키는 이름입니다.
변수의 공간을 변수 이름 또는 변수명(variable name)이라고 하고, 이 공간에 저장된 값을 변수 값(variable value)이라고 합니다.

변수에 값을 저장하는 동작을 할당(assignment)이라고 하고,
변수에 저장된 값을 읽어오는 동작은 참조(reference)라고 한다.

```js
var x; // 변수 선언
x = 10; // 변수에 값 할당 (할당 또는 저장)
console.log(x); // 변수 값 참조 (참조)
```

### 4.2 식별자(identifier)

식별자는 프로그래밍에서 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 의미합니다.
변수 이름, 함수 이름, 클래스 이름, 레이블 이름 등 다양한 요소들이 식별자로 사용될 수 있습니다.
식별자는 값이 저장된 메모리 주소를 기억하여 해당 값을 참조합니다.
변수는 값 자체를 저장하는 것이 아니라 메모리 상에 저장된 값의 위치를 기억합니다.
모든 값은 메모리 상에 존재하는 이름으로 식별될 수 있으며, 이들 이름은 모두 식별자로 간주됩니다.

### 4.3 변수 선언

변수를 사용하려면 반드시 선언이 필요하다. (ver, let, const)

```js
var x; // 변수 선언
console.log(x); // undefined
```

변수에 값을 할당하지 않으면 해당 변수는 기본적으로 undefined입니다.

변수 선언은 선언 단계(Declaration Phase)와 초기화 단계(Initialization Phase)로 나뉩니다.

- 선언 단계(Declaration Phase):
  변수 선언이 소스 코드에서 파싱될 때 발생합니다.
  변수 이름이 스코프에 등록되고 메모리에 공간이 할당됩니다.
  이 단계에서는 변수의 값이 할당되지 않습니다. 따라서 변수는 아직 초기화되지 않은 상태이며 값은 undefined입니다.
- 초기화 단계(Initialization Phase):
  변수 선언 이후 코드 실행이 변수에 도달할 때 발생합니다.
  이 단계에서 변수에 값이 할당되고 메모리 공간에 실제로 값을 저장합니다.
  이 단계에서는 변수가 선언된 위치로부터 이동하여 값을 할당합니다.

> 실행 컨텐스트(execution context)
> 모든 식별자(변수, 함수, 매개변수 등)는 해당 실행 컨텍스트에 등록됩니다. 이는 변수나 함수를 사용할 때 JavaScript 엔진이 해당 변수나 함수를 식별하고 액세스할 수 있게 해줍니다. 각 실행 컨텍스트는 자신만의 유효 범위(Scope)를 가지고 있으며, 그 안에 등록된 모든 식별자에 접근할 수 있습니다.

> var 키워드의 문제점
>
> 1.  변수 호이스팅
>     변수 및 함수 선언이 스코프의 맨 위로 끌어올려지는 것을 의미합니다.
>     코드 실행 전에 변수 및 함수 선언이 처리되는 방식을 설명합니다.
> 2.  재선언 및 재할당 가능
>     코드 오류 및 예상치 못한 동작을 초래할 수 있습니다.
> 3.  블록 스코프 지원 불가
>     코드 블록 내에서 선언된 변수가 블록 외부에서도 접근 가능하다는 것을 의미합니다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅(variable hoisting)

```js
console.log(x); // undefined
var x; // 변수 선언
```

`console.log(x)`는 변수 선언 전에 호출되어 참조 에러(ReferenceError)가 나와야 한다.
그러나 `var`키워드로 인해 호이스팅이 발생하여 `undefined`가 출력된다.

변수 선언은 소스코드가 한 줄씩 순차적으로 되는 시점(런타임)이 아니라 **그전 단계에서 먼저 실행**된다.

변수 호이스팅(Variable Hoisting)은 변수 선언이 소스 코드에서 선두로 끌어올려지는 동작을 말합니다. 이것은 변수가 실제로 선언된 위치와 상관없이 변수 선언이 소스 코드 상단으로 끌어올려진 것처럼 동작한다는 특징을 가리킵니다.

모든 식별자는 호이스팅됩니다. 이들 식별자가 선언된 위치와 상관없이 해당 스코프의 맨 위로 끌어올려지기 때문에 변수 호이스팅(Variable Hoisting), 함수 호이스팅(Function Hoisting), 클래스 호이스팅(Class Hoisting) 등의 용어가 사용됩니다.

호이스팅은 변수 선언이나 함수 선언 등의 선언문이 소스 코드에서 실행되기 이전에 먼저 처리되는 것을 의미합니다. 이로 인해 선언된 변수나 함수, 클래스는 코드에서 해당 위치보다 먼저 사용될 수 있습니다. 다만, **함수 표현식과 화살표 함수의 경우에는 호이스팅이 발생하지 않으므로 주의**해야 합니다.

```js
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;

console.log(y); // ReferenceError: Cannot access 'y' before initialization
const y = 20;
```

let과 const로 선언된 변수 x와 y는 호이스팅되어 스코프의 맨 위로 끌어올려지지만, 초기화되지 않았으므로 변수에 접근하려고 하면 초기화 전에 접근하여 에러가 발생합니다.

### 4.5 값의 할당(assignment)

```js
var x; // 변수 선언
x = 20; // 값 할당
```

변수에 값을 할당할 때 할당 연산자`=`를 사용한다.

```js
var x = 20;
```

변수 선언과 값의 할당을 하나의 문(statement)으로 단축 표현할 수 있다.
단축 표현을 해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행된다.

**변수 선언과 값의 할당의 실행 시점이 다르다.**

- 변수 선언:
  - 변수 선언은 소스 코드가 실행되기 전에 **런타임 이전**에 처리됩니다. 이 과정에서 변수는 해당 스코프 내에 등록되고 메모리 공간이 할당됩니다. 이것이 호이스팅(Hoisting)이 발생하는 부분입니다.
  - 변수 선언은 코드 실행 이전에 이미 처리되기 때문에 변수를 선언하기 이전에 해당 변수를 참조하더라도 에러가 발생하지 않습니다. 변수는 선언되었지만 값을 할당받지 않은 상태이므로 undefined가 됩니다.
- 값의 할당:

  - 값의 할당은 **런타임**에 발생합니다. 변수가 선언된 이후에 해당 변수에 값을 할당할 때 이루어집니다. 이 단계에서 변수에 실제 값이 할당되고 변수가 사용됩니다.
  - 값의 할당은 변수가 선언된 이후에 이루어지므로 초기화 이전에 변수에 접근하려고 하면 undefined가 반환됩니다.

  ```js
  console.log(x); // undefined ②
  x = 80; // 값의 할당 ③
  var x; // 변수 선언 ①
  console.log(x); // 80 ④
  ```

### 4.6 값의 재할당

```js
var x = 20; // 변수 선언과 값의 할당
x = 80; // 값의 재할당
```

var 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.

변수에 저장된 값을 재할당할 수 없다면 상수(constant)라고 한다.
상수는 단 한번만 할당할 수 있는 **변수**다

변수에 **값을 재할당하면 새로운 메모리 공간을 확보**하고, 그 공간에 새로운 값이 저장됩니다. 이전에 저장되어 있던 값을 갖고 있는 메모리 공간은 더 이상 해당 변수에 속하지 않게 되며, 이를 가비지 컬렉터가 나중에 수거하여 메모리를 해제합니다. 이 과정을 **변수의 재할당**이라고 합니다.

> 가비지 콜렉터는 프로그램에서 더 이상 사용되지 않는 메모리 공간을 자동으로 해제(release)하는 시스템으로, 메모리 관리를 돕는 중요한 도구입니다. 이를 통해 메모리 누수(leak)를 방지하고 프로그램의 성능을 향상시킬 수 있습니다. 가비지 콜렉터는 주기적으로 실행되며, 더 이상 참조되지 않는 객체를 식별하여 메모리를 해제합니다. 이는 프로그래머가 메모리 관리에 직접 신경 쓰지 않아도 되는 장점이 있습니다.

자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어입니다.

> 언매니지드 언어: 개발자가 메모리 할당과 해제를 명시적으로 관리해야 합니다. 이는 개발자가 메모리 누수와 해제되지 않은 메모리를 다루어야 하는 부담을 가져옵니다. 높은 수준의 유연성과 성능을 제공하지만, 메모리 오류에 취약할 수 있습니다.

> 매니지드 언어: 가비지 콜렉터와 같은 자동 메모리 관리 기능을 제공합니다. 이러한 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 필요가 없으며, 대신 가비지 콜렉터가 사용되지 않는 메모리를 탐지하고 자동으로 해제합니다. 이는 개발자가 메모리 관리에 대한 부담을 덜어주고, 안정성을 높여줍니다. 그러나 이에 따른 오버헤드가 발생할 수 있습니다.

### 4.7 식별자 네이밍 규칙

**식별자 네이밍 규칙**

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있습니다.
- 식별자는 특수문자를 제외한 문자, 언더스코어, 달러 기호로 시작해야 합니다. 숫자로 시작할 수 없습니다.
- 예약어는 식별자로 사용할 수 없습니다.
- 식별자는 공백을 포함할 수 없습니다.
- 식별자는 대소문자를 구분합니다.
- 식별자는 명확하고 이해하기 쉬운 이름으로 선택해야 합니다.

**네이밍 컨벤션**

변수나 함수의 이름에는 카멜 케이스 `camelCase`
생성자 함수, 클래스에는 파스칼 케이스 `PascalCase`

## 05장: 표현식과 문

### 5.1 값(value)

**값(value)**은 식(표현식expression)이 평가(evaluation)되어 생성된 결과를 말한다.

- 값은 프로그램에서 사용되는 데이터를 의미하며, 숫자, 문자열, 불리언, 함수, 객체 등 다양한 형태로 존재할 수 있습니다.
- 리터럴, 변수, 함수 호출 결과 등을 통해 값을 얻을 수 있습니다.

```js
// 숫자 리터럴
const number = 10;

// 문자열 리터럴
const message = "Hello, world!";

// 불리언 리터럴
const isTrue = true;

// 함수 리터럴
function add(x, y) {
  return x + y;
}

// 객체 리터럴
const person = { name: "John Doe", age: 30 };
```

**평가(evaluation)**는 식(표현식expression)을 해석하여 값을 생성하거나 참조하는 과정입니다.

- 자바스크립트 엔진은 식을 순서대로 계산하고, 연산자와 피연산자의 값을 사용하여 최종 결과 값을 도출합니다.

```js
const x = 10;
const y = 20;

const expression = x + y; // expression은 평가되지 않은 식입니다.

console.log(expression); // 10 + 20 을 출력하지만, 아직 평가되지 않음

const result = eval(expression); // expression을 평가하여 result에 값을 저장
console.log(result); // 30 을 출력
```

### 5.2 리터럴(literal)

**리터럴(literal)**은 사람이 직접 입력하는 값을 나타내는 표기법이며, 식의 일종으로 볼 수 있습니다.

- 리터럴은 프로그램 코드에 직접 작성된 값을 나타내는 방법입니다.
- 숫자, 문자열, 논리값, 객체 등 다양한 형태의 값을 표현하는 데 사용됩니다.

```js
// 숫자 리터럴 10과 20을 사용하여 덧셈을 수행하는 표현식
const sum = 10 + 20;

// sum 변수에는 10과 20을 더한 결과값 30이 할당됨
console.log(sum); // 출력 결과: 30
```

10 + 20은 식으로서, 숫자 리터럴 10과 20을 더하여 값을 생성하는 역할을 합니다.
이 식이 평가되면 값 30이 생성되어 변수 sum에 할당됩니다. 따라서 sum에는 값 30이 저장되어 있습니다.

### 5.3 표현식(expression)

**표현식(expression)**은 값으로 평가될 수 있는 문statement이다.
표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다
값으로 평가될 수 있는 문은 모두 표현식이다.

- 식은 값을 계산하거나 참조하는 데 사용되는 코드 조합이며, 평가를 통해 값을 생성합니다.
- 연산자, 피연산자, 함수 호출 등을 포함하며, 평가를 통해 값을 생성합니다.

```js
// 덧셈 연산
const sum = 10 + 20; // 식 : 10 + 20

// 문자열 연결 연산
const greeting = "Hello " + "JavaScript"; // 식 : "Hello " + "JavaScript"

// 함수 호출
const result = add(5, 3); // 식 : add(5, 3)

// 객체 속성 접근
const age = person.age; // 식 : person.age
```

### 5.4 문(statement)

**문(statement)**은 프로그램을 구성하는 기본 단위이며, 실제로 실행되는 코드 조각입니다.

- 변수 선언, 함수 호출, 조건 분기, 반복문, 데이터 출력 등 다양한 작업을 수행합니다.
- 평가를 통해 값을 생성하거나 참조하는 식을 포함할 수 있습니다.

```js
// 변수 선언 및 초기화
let message = "Hello";

// 함수 호출
console.log(message); // "Hello" 를 출력

// 조건 분기
if (message === "Hello") {
  console.log("Message is Hello");
}

// 반복문
for (let i = 0; i < 5; i++) {
  console.log(i); // 0, 1, 2, 3, 4 를 출력
}
```

문은 여러 개의 토큰으로 구성됩니다.
토큰은 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소입니다.

```js
const sum = 10 + 20;
```

- const은 키워드 토큰입니다.
- sum은 식별자 토큰입니다.
- =는 할당 연산자 토큰입니다.
- 10은 숫자 리터럴 토큰입니다.
- +는 덧셈 연산자 토큰입니다.
- 20은 숫자 리터럴 토큰입니다.
- ;는 세미콜론 토큰입니다.

### 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 일반적으로 문의 끝에는 세미콜론을 붙여야 합니다.
- 코드 블록은 중괄호 {}로 묶여 문의 종료를 의미하기 때문에 세미콜론 생략 가능합니다.
- 명확하고 안정적인 코드를 위해 항상 세미콜론을 명시적으로 사용하는 것이 좋습니다.

### 5.6 표현식인 문과 표현식이 아닌 문

변수 할당을 사용하면 표현식 문과 표현식이 아닌 문을 간단하고 명확하게 구별할 수 있습니다.

- 식인 문: 변수에 할당하면 값이 저장됩니다.
- 표현식이 아닌 문: 변수에 할당하면 에러가 발생합니다.

```js
let result; // 변수 선언

// 식인 문 할당
result = "Hello"; // 성공: 문자열 값 할당
result = 10 + 20; // 성공: 덧셈 결과 값 할당
result = true; // 성공: 논리값 할당

// 표현식이 아닌 문 할당 (에러 발생)
result = if (condition) {}; // SyntaxError
result = while (i < 10) {}; // SyntaxError
result = console.log("Hello, world!"); // SyntaxError
```

> Chrome 개발자 도구에서 표현식이 아닌 문을 실행하면 undefined를 출력합니다.
> 이는 해당 문이 값을 반환하지 않기 때문입니다.
> 표현식이 아닌 문의 실행 결과를 완료값이라고 합니다.
> 완료값은 다른 값과 마찬가지로 변수에 할당하거나 참조할 수 없습니다.

## 17장: 생성자 함수에 의한 객체 생성

### 17.1 Object 생성자 함수

### 17.2 생성자(constructor) 함수

#### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴을 사용하여 객체를 생성하는 방식은 간편하고 직관적이지만 다음과 같은 문제점을 가지고 있습니다.

- 코드 중복 : 동일한 구조를 가진 여러 객체 생성 시 동일 코드 작성 필요
- 비효율성 : 객체 프로퍼티 및 메서드 증가 시 코드 길어짐 및 가독성 저하
- 상속 불가능 : 객체 리터럴은 단순 객체 생성만 가능하며, 상속 기능 제공 불가능
- 초기화 문제 : 객체 리터럴 사용 시 프로퍼티 초기화 과정 명시적으로 작성 필요

#### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수를 사용하여 객체를 생성하는 방식은 다음과 같은 장점을 가지고 있습니다.

- 코드 재사용 : 동일한 구조를 가진 여러 객체를 생성해야 할 때 유용합니다.
- 효율성 : 객체의 프로퍼티와 메서드가 많아도 코드를 간결하게 작성할 수 있습니다.
- 상속 가능 : 다른 객체로부터 상속받는 기능을 제공합니다.
- 초기화 용이 : 생성자 함수에서 객체의 프로퍼티를 초기화하는 코드를 작성할 수 있습니다.

#### 17.2.3 생성자 함수의 인스턴스 생성 과정

1. new 연산자 호출: new 연산자를 사용하여 생성자 함수를 호출합니다.
1. 새로운 객체 생성: new 연산자는 생성자 함수 내에서 this 키워드를 사용하여 새로운 객체를 생성합니다.
1. 생성자 함수 실행: 생성자 함수 내의 코드가 실행됩니다. 이 코드는 일반적으로 객체의 프로퍼티를 초기화하는 역할을 수행합니다.
1. 객체 반환: 생성자 함수는 생성된 객체를 반환합니다.

#### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

모든 함수는 [[Call]]과 [[Construct]]이라는 두 개의 내부 메서드를 가지고 있습니다.

- [[Call]] 메서드는 일반적인 함수 호출 방식으로 사용됩니다.
- [[Construct]] 메서드는 new 연산자를 사용하여 객체를 생성할 때 사용됩니다.

생성자 함수는 [[Construct]] 메서드를 통해 객체 생성 과정을 수행하도록 정의됩니다.

#### 17.2.5 constructor와 non-constructor의 구분

생성자 함수와 일반 함수는 다음과 같은 기준으로 구분할 수 있습니다.

- [[Construct]] 메서드: 생성자 함수는 [[Construct]] 메서드를 가지고 있지만 일반 함수는 가지고 있지 않습니다.
- prototype 속성: 생성자 함수는 prototype 속성을 가지고 있으며, 이 속성을 통해 생성된 객체에 메서드를 추가할 수 있습니다. 일반 함수는 prototype 속성을 가지고 있지 않습니다.
- 명명관례: 일반적으로 생성자 함수는 이름의 첫 문자를 대문자로 작성합니다. 예를 들어 Person() 처럼 작성합니다. 일반 함수는 이러한 명명 규칙을 따르지 않아도 됩니다.

#### 17.2.6 new 연산자

new 연산자는 다음과 같은 두 가지 역할을 수행합니다.

- 생성자 함수 호출: new 연산자는 생성자 함수를 호출합니다.
- 새로운 객체 생성: new 연산자는 생성자 함수 내에서 this 키워드를 사용하여 새로운 객체를 생성합니다.

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person1 = new Person("Lee", 30);
const person2 = new Person("Kim", 25);
```

위 예제에서 Person 함수는 생성자 함수이며 new 연산자를 사용하여 person1 및 person2 객체를 생성합니다.

new 연산자의 중요한 특징

- new 연산자는 객체 생성 전용 연산자입니다. 일반 함수 호출에는 사용할 수 없습니다.
- new 연산자는 생성자 함수의 [[Construct]] 메서드를 호출합니다.
- new 연산자는 생성된 객체를 반환합니다.

#### 17.2.7 new.target

new.target은 [[Construct]] 메서드를 통해 호출된 함수 자체를 가리키는 변수입니다. 즉, new 연산자를 사용하여 생성자 함수를 호출할 때 new.target 변수에는 해당 생성자 함수가 할당됩니다.

다음 예제는 new.target 변수를 사용하는 방법을 보여줍니다.

```js
function Person(name, age) {
  if (new.target !== Person) {
    throw new Error("Must be called using new");
  }

  this.name = name;
  this.age = age;
}

const person1 = new Person("Lee", 30);
// person1 객체 생성 성공

const person2 = Person("Kim", 25);
// Error: Must be called using new
```

위 예제에서 Person 생성자 함수는 new.target 변수를 사용하여 자신이 new 연산자를 통해 호출되었는지 확인합니다. 만약 new 연산자를 사용하지 않고 일반 함수 호출 방식으로 호출된 경우 에러를 발생시킵니다.

이처럼 new.target 변수는 생성자 함수가 올바르게 사용되었는지 확인하는 데 유용하게 사용될 수 있습니다.
